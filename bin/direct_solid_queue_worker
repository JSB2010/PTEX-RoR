#!/usr/bin/env ruby
# frozen_string_literal: true

require File.expand_path('../config/environment', __dir__)

# Setup logging
logger = Logger.new(Rails.root.join('log', 'solid_queue_direct.log'))
logger.level = Logger::INFO
logger.formatter = proc do |severity, datetime, progname, msg|
  "[#{datetime}] [#{severity}] #{msg}\n"
end

# Ensure consistent timezone handling
ENV['TZ'] = 'UTC'
Time.zone = 'UTC'

logger.info "Starting direct SolidQueue worker process"

# Improved connection handling with retry
def with_connection_handling
  ActiveRecord::Base.connection_pool.with_connection do
    yield
  end
rescue ActiveRecord::ConnectionNotEstablished, PG::ConnectionBad => e
  logger.error "Database connection error: #{e.message}"
  ActiveRecord::Base.connection_pool.disconnect!
  ActiveRecord::Base.establish_connection
  retry
end

# Clean up any existing processes for this host
SolidQueue::Process.where(hostname: Socket.gethostname, kind: "DirectWorker").find_each(&:deregister)

# Improved shutdown handling
shutdown = false
heartbeat_thread = nil

# Register process with database-level locking to prevent duplicates
process = nil
begin
  # Use an advisory lock to ensure only one process registration happens at a time
  ActiveRecord::Base.transaction do
    ActiveRecord::Base.connection.execute("SELECT pg_advisory_xact_lock(#{Process.pid})")
    
    process = SolidQueue::Process.register(
      kind: "DirectWorker",
      name: "direct-worker-#{SecureRandom.hex(8)}",
      metadata: {
        queues: ["default", "mailers", "active_storage", "maintenance"],
        polling_interval: 1.0,
        batch_size: 100,
        pid: Process.pid,
        hostname: Socket.gethostname
      }
    )
    logger.info "Registered process: #{process.name} (#{process.id})"
  end
rescue => e
  logger.error "Failed to register process: #{e.message}"
  exit 1
end

# Write PID file
pid_file = Rails.root.join('tmp', 'pids', 'solid_queue.pid')
FileUtils.mkdir_p(File.dirname(pid_file))
File.write(pid_file, Process.pid)
logger.info "PID stored at #{pid_file}: #{Process.pid}"

# Trap signals for graceful shutdown
Signal.trap("INT") do
  logger.info "Received INT signal, shutting down gracefully..."
  shutdown = true
  heartbeat_thread&.exit
end

Signal.trap("TERM") do
  logger.info "Received TERM signal, shutting down gracefully..."
  shutdown = true
  heartbeat_thread&.exit
end

# Start dedicated heartbeat thread
heartbeat_thread = Thread.new do
  while !shutdown
    begin
      with_connection_handling do
        process.update_heartbeat!
        logger.debug "Updated heartbeat for process #{process.id}"
      end
      sleep 15 # Update heartbeat every 15 seconds
    rescue => e
      logger.error "Heartbeat error: #{e.message}"
      sleep 5 # Back off on errors
    end
  end
end

# Main processing loop
while !shutdown
  begin
    with_connection_handling do
      # Process ready jobs with improved error handling
      SolidQueue::ReadyExecution.includes(:job).find_each do |execution|
        job = execution.job
        next unless job

        begin
          logger.info "Processing job #{job.id}: #{job.class_name}"
          
          # Parse arguments safely
          args = begin
            JSON.parse(job.arguments || "[]")
          rescue JSON::ParserError => e
            logger.error "Invalid job arguments for #{job.id}: #{e.message}"
            job.mark_as_failed("Invalid job arguments: #{e.message}")
            next
          end
          
          if job.active_job_id.present?
            job_class = job.class_name.constantize
            logger.info "Executing ActiveJob: #{job_class}"
            job_class.perform_now(*args)
          else
            klass = job.class_name.constantize
            if job.method_name.present?
              klass.send(job.method_name, *args)
            else
              klass.new.perform(*args)
            end
          end
          
          job.update!(finished_at: Time.current)
          execution.destroy
          
        rescue => e
          logger.error "Error processing job #{job.id}: #{e.message}"
          logger.error e.backtrace.join("\n")
          job.mark_as_failed("#{e.class}: #{e.message}")
        ensure
          # Make sure we release any advisory locks
          execution.try(:release_lock)
        end
      end
    end
    sleep 1 # Prevent tight loop, adjust as needed
  rescue => e
    logger.error "Worker error: #{e.message}"
    logger.error e.backtrace.join("\n")
    sleep 5 # Back off on errors
  end
end

# Clean up when shutting down
logger.info "Worker shutting down..."
heartbeat_thread.join # Wait for heartbeat thread to finish

with_connection_handling do
  process.deregister if process&.persisted?
end

File.unlink(pid_file) rescue nil
logger.info "Worker shutdown complete"
