#!/usr/bin/env ruby
# A completely new approach to starting the Rails server with all components

require 'fileutils'
require 'socket'
require 'timeout'

# Set up paths
APP_ROOT = File.expand_path('..', __dir__)
PID_DIR = File.join(APP_ROOT, 'tmp', 'pids')
LOG_DIR = File.join(APP_ROOT, 'log')

# Create directories if they don't exist
FileUtils.mkdir_p(PID_DIR)
FileUtils.mkdir_p(LOG_DIR)

# Helper method to log messages
def log(message)
  puts "[#{Time.now.strftime('%Y-%m-%d %H:%M:%S')}] #{message}"
end

# Helper method to run a command
def run_command(command)
  log "Running: #{command}"
  system(command)
end

# Check if PostgreSQL is running
log "Checking PostgreSQL status..."
pg_running = system("pg_isready -q")
unless pg_running
  log "Starting PostgreSQL..."
  run_command("brew services start postgresql@14")

  # Wait for PostgreSQL to start with a timeout
  started = false
  begin
    Timeout.timeout(30) do
      until system("pg_isready -q")
        sleep 1
      end
      started = true
    end
  rescue Timeout::Error
    log "ERROR: Failed to start PostgreSQL within timeout. Please start it manually."
    exit 1
  end

  if started
    log "PostgreSQL started successfully."
  end
else
  log "PostgreSQL is already running."
end

# Check if Redis is running
log "Checking Redis status..."
redis_running = system("redis-cli ping > /dev/null 2>&1")
unless redis_running
  log "Starting Redis..."
  run_command("brew services start redis")

  # Wait for Redis to start with a timeout
  started = false
  begin
    Timeout.timeout(20) do
      until system("redis-cli ping > /dev/null 2>&1")
        sleep 1
      end
      started = true
    end
  rescue Timeout::Error
    log "ERROR: Failed to start Redis within timeout. Please start it manually."
    exit 1
  end

  if started
    log "Redis started successfully."
  end
else
  log "Redis is already running."
end

# Kill any existing SolidQueue processes
log "Checking for existing SolidQueue processes..."
pkill_output = `pgrep -f "solid_queue_monitor.rb" || echo ""`.strip
unless pkill_output.empty?
  log "Killing existing SolidQueue processes: #{pkill_output}"
  system("pkill -f solid_queue_monitor.rb")
  sleep 2

  # Double-check that processes are actually killed
  pkill_output = `pgrep -f "solid_queue_monitor.rb" || echo ""`.strip
  unless pkill_output.empty?
    log "Forcefully killing remaining processes: #{pkill_output}"
    system("pkill -9 -f solid_queue_monitor.rb")
    sleep 1
  end
end

# Clean up any stale PID files
log "Cleaning up stale PID files..."
Dir.glob(File.join(PID_DIR, "*.pid")).each do |file|
  begin
    File.delete(file)
  rescue => e
    log "Error deleting PID file #{file}: #{e.message}"
  end
end

# Clean up stale processes in the database
log "Cleaning up database records..."
run_command("cd #{APP_ROOT} && bin/rails runner 'begin; SolidQueue::Process.where(hostname: Socket.gethostname).destroy_all; rescue => e; puts \"Error cleaning up stale processes: #{e.message}\"; end'")

# Start SolidQueue in a separate process
log "Starting SolidQueue..."
solid_queue_pid = spawn("cd #{APP_ROOT} && ruby bin/solid_queue_monitor.rb",
                        out: [File.join(LOG_DIR, "solid_queue_monitor.log"), "a"],
                        err: [File.join(LOG_DIR, "solid_queue_monitor.log"), "a"])
Process.detach(solid_queue_pid)

# Write the PID to a file
File.write(File.join(PID_DIR, "solid_queue_monitor.pid"), solid_queue_pid.to_s)
log "SolidQueue started with PID: #{solid_queue_pid}"

# Wait a moment to make sure it's running
sleep 3

# Verify that the process is still running
if system("ps -p #{solid_queue_pid} > /dev/null")
  log "SolidQueue is running successfully (PID: #{solid_queue_pid})"
else
  log "WARNING: SolidQueue may not have started properly. Check logs for details."
end

# Register a shutdown hook to clean up SolidQueue
at_exit do
  if solid_queue_pid && system("ps -p #{solid_queue_pid} > /dev/null")
    log "Stopping SolidQueue (PID: #{solid_queue_pid})..."
    Process.kill("TERM", solid_queue_pid) rescue nil
  end
end

# Start the Rails server
log "Starting Rails server..."
exec("cd #{APP_ROOT} && bundle exec rails server #{ARGV.join(' ')}")
