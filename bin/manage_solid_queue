#!/usr/bin/env ruby

require File.expand_path('../config/environment', __dir__)
require 'optparse'
require 'fileutils'

PID_FILE = Rails.root.join('tmp', 'pids', 'solid_queue_monitor.pid')

def write_pid(pid)
  FileUtils.mkdir_p(File.dirname(PID_FILE))
  File.write(PID_FILE, pid.to_s)
end

def read_pid
  File.read(PID_FILE).to_i if File.exist?(PID_FILE)
end

def remove_pid
  File.delete(PID_FILE) if File.exist?(PID_FILE)
end

def start_daemon
  return yield if ENV['FOREGROUND']

  # Double fork to properly daemonize
  exit if fork # Parent exits, child continues
  Process.setsid # Become session leader
  exit if fork # Parent exits, child continues

  # Redirect standard streams
  STDIN.reopen('/dev/null')
  STDOUT.reopen("#{Rails.root}/log/solid_queue.log", 'a')
  STDERR.reopen(STDOUT)
  STDOUT.sync = STDERR.sync = true

  # Write PID file
  write_pid(Process.pid)

  # Set up signal handlers
  Signal.trap('TERM') { SolidQueueMonitor.stop }
  Signal.trap('INT') { SolidQueueMonitor.stop }

  # Change working directory
  Dir.chdir(Rails.root)

  yield
rescue => e
  Rails.logger.error "Daemon error: #{e.class} - #{e.message}\n#{e.backtrace.join("\n")}"
  exit 1
ensure
  remove_pid
end

def stop_processes
  if pid = read_pid
    begin
      # Send TERM signal and wait for graceful shutdown
      Process.kill('TERM', pid)
      20.times do # Wait up to 20 seconds
        sleep 1
        begin
          Process.kill(0, pid) # Check if process exists
        rescue Errno::ESRCH
          return true # Process is gone
        end
      end
      
      # Force kill if still running
      Process.kill('KILL', pid) rescue nil
      sleep 1
    rescue Errno::ESRCH
      # Process not found
    ensure
      remove_pid
    end
  end
  
  # Clean up any stale processes in the database
  SolidQueue::Process.where(hostname: Socket.gethostname).find_each(&:deregister)
end

def wait_for_startup
  10.times do # Wait up to 10 seconds for processes to start
    processes = SolidQueue::Process.where('last_heartbeat_at > ?', 30.seconds.ago).count
    return true if processes >= 2 # We expect at least worker and dispatcher
    sleep 1
  end
  false
end

def print_status
  puts "\nSolidQueue Status:"
  puts "==================="
  
  processes = SolidQueue::Process.all
  active_processes = processes.where('last_heartbeat_at > ?', 30.seconds.ago)
  
  puts "Active Processes: #{active_processes.count}/#{processes.count}"
  puts "Jobs Status:"
  puts "  Ready: #{SolidQueue::Job.ready.count}"
  puts "  Running: #{SolidQueue::Job.joins(:claimed_execution).count}"
  puts "  Failed: #{SolidQueue::FailedExecution.count}"
  puts "  Scheduled: #{SolidQueue::Job.scheduled.count}"
  puts "\nProcess Details:"
  
  processes.each do |process|
    status = process.last_heartbeat_at > 30.seconds.ago ? 'ALIVE' : 'DEAD'
    puts "#{process.name} (#{process.kind}) - PID: #{process.pid} - Status: #{status}"
  end
end

# Parse command line options
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} [start|stop|restart|status] [options]"
  opts.on('-f', '--foreground', 'Run in foreground (no daemonize)') do
    ENV['FOREGROUND'] = '1'
  end
  opts.on('-h', '--help', 'Show this help message') do
    puts opts
    exit
  end
end.parse!

command = ARGV[0] || 'status'

case command
when 'start'
  if pid = read_pid
    begin
      Process.kill(0, pid)
      puts "SolidQueue processes are already running (PID: #{pid})"
      print_status
      exit 1
    rescue Errno::ESRCH
      remove_pid
    end
  end
  
  puts "Starting SolidQueue processes..."
  if ENV['FOREGROUND']
    SolidQueueMonitor.start
  else
    start_daemon do
      begin
        SolidQueueMonitor.start
      rescue => e
        Rails.logger.error "Monitor error: #{e.class} - #{e.message}\n#{e.backtrace.join("\n")}"
        exit 1
      end
    end
    
    if wait_for_startup
      puts "SolidQueue processes started successfully"
      print_status
    else
      puts "Warning: Processes may not have started correctly"
      print_status
      exit 1
    end
  end

when 'stop'
  puts "Stopping SolidQueue processes..."
  if stop_processes
    puts "All processes stopped successfully"
  else
    puts "Warning: Some processes may still be running"
    print_status
  end

when 'restart'
  puts "Restarting SolidQueue processes..."
  stop_processes
  sleep 2
  
  if ENV['FOREGROUND']
    SolidQueueMonitor.start
  else
    start_daemon do
      begin
        SolidQueueMonitor.start
      rescue => e
        Rails.logger.error "Monitor error: #{e.class} - #{e.message}\n#{e.backtrace.join("\n")}"
        exit 1
      end
    end
    
    if wait_for_startup
      puts "SolidQueue processes restarted successfully"
      print_status
    else
      puts "Warning: Processes may not have started correctly"
      print_status
      exit 1
    end
  end

when 'status'
  print_status

else
  puts "Unknown command: #{command}"
  puts "Usage: #{File.basename($0)} [start|stop|restart|status] [options]"
  exit 1
end